# 核心服务详细设计

## 服务模块总览

### 1. 订单服务 (OrderService)

#### 功能职责
- 订单生命周期管理 (创建、支付、发货、完成、取消)
- 订单状态流转控制
- 订单数据一致性保证
- 订单查询与统计

#### 核心接口设计

**订单创建接口**
- 输入参数：用户ID、商品ID、数量、促销ID、支付方式、收货地址
- 输出结果：订单ID、订单金额、订单状态、支付链接
- 处理方式：异步处理支持高并发场景

**订单查询接口**
- 订单详情查询：根据订单ID获取完整订单信息
- 订单列表查询：支持分页、状态筛选、时间范围查询
- 性能优化：缓存热点数据，分库分表查询

**订单状态管理**
- 状态更新：支持状态流转控制，防止非法状态变更
- 订单取消：支持用户主动取消和系统自动取消
- 状态追踪：记录所有状态变更历史

**订单状态定义**
- PENDING：待支付
- PAID：已支付
- CONFIRMED：已确认
- SHIPPING：配送中
- COMPLETED：已完成
- CANCELLED：已取消
- REFUNDED：已退款

#### 订单状态流转规则
**状态转换规则**
- PENDING → PAID, CANCELLED
- PAID → CONFIRMED, REFUNDED  
- CONFIRMED → SHIPPING, REFUNDED
- SHIPPING → COMPLETED, REFUNDED
- COMPLETED → REFUNDED
- CANCELLED → 终态
- REFUNDED → 终态

**状态机特性**
- 单向流转：状态变更不可逆，确保数据一致性
- 权限控制：不同角色具有不同的状态操作权限
- 事件驱动：状态变更触发相应业务事件
- 审计追踪：记录所有状态变更的操作人和原因

### 2. 库存服务 (InventoryService)

#### 功能职责
- 商品库存管理
- 库存扣减与释放
- 库存预占与确认
- 库存同步与对账

#### 核心接口设计

**库存查询接口**
- 单商品库存查询：根据商品ID获取库存信息
- 批量库存查询：支持一次查询多个商品的库存
- 库存信息包含：总库存、可用库存、预占库存、版本号

**库存预占机制**
- 预占请求：商品ID、数量、订单ID、超时时间
- 预占响应：成功标识、预占ID、错误信息
- 超时处理：15分钟自动释放预占库存
- 幂等性保证：重复请求返回相同结果

**库存操作接口**
- 确认扣减：支付成功后确认预占库存扣减
- 释放预占：订单取消或超时后释放预占库存
- 直接扣减：秒杀场景下的即时库存扣减
- 库存回滚：退款时增加库存数量
- 库存设置：管理员设置商品总库存

**分布式锁机制**
- Redis分布式锁：保护库存操作的原子性
- 锁超时控制：防止死锁，默认5秒超时
- 锁续期机制：长时间操作支持锁续期
- 锁释放保证：确保锁的正确释放

#### 库存扣减算法 (防超卖)

**方案1: 悲观锁方案**
- Redis分布式锁：首先获取商品级别的分布式锁
- MySQL行锁：使用SELECT FOR UPDATE锁定库存记录
- 原子扣减：在锁保护下执行库存扣减操作
- 适用场景：高并发抢购、库存紧张场景
- 优点：强一致性，100%防超卖
- 缺点：性能相对较低，可能出现锁等待

**方案2: 乐观锁方案**  
- 版本号控制：使用version字段实现乐观锁
- CAS操作：比较版本号并更新库存
- 重试机制：失败时指数退避重试，最多3次
- 适用场景：库存充足，并发度中等的场景
- 优点：性能较高，无锁等待
- 缺点：高并发时重试频繁，成功率相对较低

**方案选择策略**
- 秒杀场景：使用悲观锁方案确保不超卖
- 普通下单：根据库存数量选择合适方案
- 预占场景：使用悲观锁确保预占成功
- 批量操作：考虑分批处理减少锁竞争

### 3. 用户服务 (UserService)

#### 功能职责
- 用户注册与认证
- 用户信息管理
- 用户权限控制
- 用户行为追踪

#### 核心接口设计

**用户注册接口**
- 注册信息：用户名、密码、邮箱、手机号、验证码
- 校验规则：用户名唯一性、密码强度、手机号格式
- 安全措施：密码加盐哈希、验证码校验、频率限制
- 返回结果：用户ID、访问令牌、刷新令牌

**用户登录接口**
- 登录方式：支持用户名/邮箱/手机号登录
- 安全控制：密码错误次数限制、IP黑名单
- 设备管理：记录登录设备信息，支持多设备登录
- Token管理：JWT访问令牌 + 刷新令牌机制

**用户信息管理**
- 基础信息：姓名、头像、性别、生日等
- 扩展信息：等级、积分、余额、偏好设置
- 地址管理：支持多个收货地址，默认地址设置
- 隐私保护：敏感信息加密存储，访问权限控制

**权限认证机制**
- JWT令牌：包含用户ID、角色、权限、过期时间
- 角色权限：RBAC模型，支持角色继承
- 接口鉴权：每个接口配置所需权限
- 令牌刷新：访问令牌过期自动刷新机制

### 4. 支付服务 (PaymentService)

#### 功能职责
- 支付流程编排
- 多种支付方式集成
- 支付状态管理
- 支付安全控制

#### 核心接口设计

**支付创建接口**
- 支付信息：订单ID、用户ID、金额、支付方式
- 支付方式：支付宝、微信支付、银行卡、余额支付
- 回调配置：同步回调URL、异步通知URL
- 返回结果：支付单号、支付链接、支付状态

**支付状态查询**
- 状态信息：支付单号、订单ID、金额、状态、交易号
- 实时查询：调用第三方接口获取最新状态
- 缓存机制：热点支付单状态缓存
- 状态同步：定时任务同步支付状态

**支付回调处理**
- 签名验证：验证第三方平台回调签名
- 幂等处理：重复回调的幂等性保证
- 异步处理：回调消息放入队列异步处理
- 状态更新：更新支付状态并触发后续流程

**退款管理**
- 退款申请：支持全额退款和部分退款
- 退款状态：处理中、成功、失败
- 自动退款：符合条件的订单自动退款
- 退款通知：退款结果实时通知用户

#### 支付状态定义
- PENDING：待支付
- PAYING：支付中
- SUCCESS：支付成功
- FAILED：支付失败
- CANCELLED：已取消
- TIMEOUT：超时

#### 退款状态定义
- PENDING：退款中
- SUCCESS：退款成功
- FAILED：退款失败

### 5. 促销服务 (PromotionService)

#### 功能职责
- 优惠券管理
- 秒杀活动管理
- 促销规则引擎
- 营销数据统计

#### 核心接口设计

**优惠券管理**
- 优惠券类型：满减券、折扣券、包邮券
- 发放机制：定时发放、活动发放、用户领取
- 使用规则：使用条件、有效期、使用限制
- 状态管理：未使用、已使用、已过期

**秒杀活动管理**
- 活动配置：商品、价格、数量、时间、限购
- 预热机制：活动开始前预加载数据到缓存
- 流量控制：多级限流保护系统稳定
- 结果统计：实时统计参与人数、成功率

**促销规则引擎**
- 规则配置：灵活的促销规则配置
- 规则匹配：根据订单信息匹配适用规则
- 优惠计算：自动计算最优优惠方案
- 规则验证：确保规则的正确性和一致性

**营销数据统计**
- 实时统计：优惠券使用率、活动参与度
- 效果分析：转化率、客单价、复购率
- 用户分析：用户偏好、行为轨迹
- 报表导出：支持多维度数据报表

## 服务间通信设计

### 1. 同步调用 (gRPC)
- **订单→库存**：库存预占、确认、释放
- **订单→支付**：创建支付单、查询支付状态
- **订单→促销**：优惠计算、优惠券核销
- **用户→权限**：用户认证、权限验证

### 2. 异步消息 (Kafka)
- **订单事件**：订单创建、状态变更、支付成功
- **库存事件**：库存变更、库存预警
- **用户事件**：用户注册、登录、行为轨迹
- **支付事件**：支付成功、退款完成

### 3. 事件定义规范
**事件消息结构**
- Header：消息ID、事件类型、版本、时间戳、来源
- Payload：业务数据
- Metadata：重试次数、标签信息

**事件命名规范**
- 格式：{环境}.{业务域}.{事件类型}.{版本}
- 示例：prod.order.created.v1

### 4. 服务发现与负载均衡
**服务注册**
- 服务信息：名称、ID、地址、元数据
- 健康检查：定期检查服务健康状态
- 自动注销：服务下线自动注销

**负载均衡策略**
- 轮询：请求均匀分发到各个实例
- 随机：随机选择服务实例
- 权重：根据实例性能分配权重
- 一致性哈希：特定请求固定路由到特定实例

## 错误处理与重试机制

### 1. 统一错误码定义
**错误码分类**
- 1000-1999：通用错误
- 2000-2999：用户相关错误
- 3000-3999：订单相关错误
- 4000-4999：库存相关错误
- 5000-5999：支付相关错误

**常见错误码**
- 1001：参数错误
- 1002：内部错误
- 1003：请求超时
- 2001：用户不存在
- 3001：订单不存在
- 4001：库存不足
- 5001：支付失败

### 2. 重试机制
**重试策略**
- 指数退避：重试间隔逐步增加
- 最大重试：限制最大重试次数
- 熔断机制：连续失败时停止重试
- 重试条件：只对可重试的错误进行重试

**重试场景**
- 网络超时：临时网络问题
- 系统繁忙：下游服务负载过高
- 资源冲突：并发冲突导致的失败
- 第三方接口：外部接口临时不可用

### 3. 降级与容错
**服务降级**
- 功能降级：关闭非核心功能
- 性能降级：返回缓存数据
- 接口降级：返回默认值或错误信息

**容错机制**
- 超时控制：设置合理的接口超时时间
- 断路器：防止故障扩散
- 舱壁模式：隔离不同类型的请求
- 回退策略：主流程失败时的备用方案

## 性能优化策略

### 1. 连接池管理
**数据库连接池**
- 初始连接数：根据并发量设置初始连接
- 最大连接数：防止连接数过多影响性能
- 连接回收：空闲连接自动回收
- 连接监控：监控连接池使用情况

**Redis连接池**
- 连接复用：多个请求复用相同连接
- 连接超时：设置连接和读取超时时间
- 连接验证：使用前验证连接有效性
- 失败重试：连接失败时自动重试

### 2. 缓存优化
**缓存策略**
- 热点数据：用户信息、商品信息、库存信息
- 缓存层级：本地缓存 + 分布式缓存
- 过期策略：根据数据特性设置合理的TTL
- 预热机制：系统启动时预加载热点数据

**缓存一致性**
- 更新策略：先更新数据库，再删除缓存
- 版本控制：缓存数据包含版本号
- 异步更新：通过消息队列异步更新缓存
- 最终一致性：保证数据最终一致

### 3. 对象池模式
**对象池设计**
- 对象创建：预先创建一定数量的对象
- 对象获取：从池中获取可用对象
- 对象归还：使用完成后归还给池
- 池容量管理：动态调整池的大小

**适用场景**
- 连接对象：数据库连接、Redis连接
- 重对象：大对象的创建和销毁成本高
- 频繁创建：频繁创建销毁的对象
- 资源限制：系统资源有限制的场景

这些核心服务设计提供了：
1. **清晰的接口定义** - 便于团队协作开发
2. **完整的错误处理** - 提高系统稳定性
3. **高性能优化** - 支持高并发场景
4. **扩展性考虑** - 便于功能迭代和扩展
